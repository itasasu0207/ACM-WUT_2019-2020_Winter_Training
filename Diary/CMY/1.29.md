Floyd算法
算法核心语句
for(k=1;k<=n;k++)  
for(i=1;i<=n;i++)  
for(j=1;j<=n;j++)  
if(e[i][j]>e[i][k]+e[k][j] )   
e[i][j]=e[i][k]+e[k][j];
Floyd-Warshall算法不能解决带有“负权回路”的图

Dijkstra算法
首先把起点到所有点的距离存下来找个最短的，然后遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。

Luogu P2935 (Floyed)
先用Flody算出各点之间的最短路，再求距离和的最小值

Luogu P1841 (Floyed)
如果两点之间只有一条最短路的话，那么这条路上所有的点都是重要城市。如果不止有一条最短路，那么对于这两个点来说，中间的非重合边中间的点不是重要城市。进行Floyd的时候，如果两个点之间距离被更新，则标记当前最外层的k是重要城市。如果有相等长度的路径，则说明两点间有多条最短路，则把两点间重要城市的标记撤销。
